{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nimport { createContext, useContext } from \"react\";\nimport { useInteractionMode } from \"./useInteractionMode\";\n/**\n * @internal\n */\n\nvar modeContext = createContext(\"mouse\");\n/**\n * @internal\n */\n\nvar parentContext = createContext(false);\n/**\n * @internal\n */\n\nvar UserInteractionModeProvider = modeContext.Provider;\n/**\n * @internal\n */\n\nvar ParentProvider = parentContext.Provider;\n/**\n * Returns the current user interaction mode.\n *\n * @returns {@link UserInteractionMode}\n */\n\nexport function useUserInteractionMode() {\n  return useContext(modeContext);\n}\n/**\n * Example:\n *\n * ```ts\n * const isKeyboard = useIsUserInteractionMode(\"keyboard\");\n * // do stuff if keyboard only\n * ```\n *\n * @param mode - The {@link UserInteractionMode} to check against.\n * @returns `true` if the current user interaction mode matches the provided\n * mode.\n */\n\nexport function useIsUserInteractionMode(mode) {\n  return useUserInteractionMode() === mode;\n}\n/**\n * This component is used to determine how the user is current interacting with\n * your app as well as modifying the `document.body`'s `className` with the\n * current mode. This is what allows the `rmd-utils-phone-only`,\n * `rmd-utils-keyboard-only`, and `rmd-utils-mouse-only` mixins to work.\n *\n * @remarks \\@since 2.6.0 Renamed from `InteractionModeListener`\n * @throws When this component has been mounted multiple times in your app.\n */\n\nexport function UserInteractionModeListener(_a) {\n  var children = _a.children;\n  var mode = useInteractionMode();\n\n  if (useContext(parentContext)) {\n    throw new Error(\"Mounted multiple `UserInteractionModeListener` components.\");\n  }\n\n  return _jsx(UserInteractionModeProvider, __assign({\n    value: mode\n  }, {\n    children: _jsx(ParentProvider, __assign({\n      value: true\n    }, {\n      children: children\n    }))\n  }));\n}","map":{"version":3,"sources":["../../src/mode/UserInteractionModeListener.tsx"],"names":[],"mappings":";;;;;;;;;;;;;;;AACA,SAAS,aAAT,EAAwB,UAAxB,QAA0C,OAA1C;AAGA,SAAS,kBAAT,QAAmC,sBAAnC;AAEA;;;;AAGA,IAAM,WAAW,GAAG,aAAa,CAAsB,OAAtB,CAAjC;AAEA;;;;AAGA,IAAM,aAAa,GAAG,aAAa,CAAC,KAAD,CAAnC;AAEA;;;;AAGQ,IAAU,2BAA2B,GAAK,WAAW,CAAhB,QAArC;AAER;;;;AAGQ,IAAU,cAAc,GAAK,aAAa,CAAlB,QAAxB;AAER;;;;;;AAKA,OAAM,SAAU,sBAAV,GAAgC;AACpC,SAAO,UAAU,CAAC,WAAD,CAAjB;AACD;AAED;;;;;;;;;;;;;AAYA,OAAM,SAAU,wBAAV,CAAmC,IAAnC,EAA4D;AAChE,SAAO,sBAAsB,OAAO,IAApC;AACD;AAUD;;;;;;;;;;AASA,OAAM,SAAU,2BAAV,CAAsC,EAAtC,EAE6B;MADjC,QAAQ,GAAA,EAAA,CAAA,Q;AAER,MAAM,IAAI,GAAG,kBAAkB,EAA/B;;AACA,MAAI,UAAU,CAAC,aAAD,CAAd,EAA+B;AAC7B,UAAM,IAAI,KAAJ,CACJ,4DADI,CAAN;AAGD;;AAED,SACE,IAAA,CAAC,2BAAD,EAA4B,QAAA,CAAA;AAAC,IAAA,KAAK,EAAE;AAAR,GAAA,EAAY;AAAA,IAAA,QAAA,EACtC,IAAA,CAAC,cAAD,EAAe,QAAA,CAAA;AAAC,MAAA,KAAK,EAAA;AAAN,KAAA,EAAM;AAAA,MAAA,QAAA,EAAE;AAAF,KAAN,CAAf;AADsC,GAAZ,CAA5B,CADF;AAKD","sourceRoot":"","sourcesContent":["var __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nimport { createContext, useContext } from \"react\";\nimport { useInteractionMode } from \"./useInteractionMode\";\n/**\n * @internal\n */\nvar modeContext = createContext(\"mouse\");\n/**\n * @internal\n */\nvar parentContext = createContext(false);\n/**\n * @internal\n */\nvar UserInteractionModeProvider = modeContext.Provider;\n/**\n * @internal\n */\nvar ParentProvider = parentContext.Provider;\n/**\n * Returns the current user interaction mode.\n *\n * @returns {@link UserInteractionMode}\n */\nexport function useUserInteractionMode() {\n    return useContext(modeContext);\n}\n/**\n * Example:\n *\n * ```ts\n * const isKeyboard = useIsUserInteractionMode(\"keyboard\");\n * // do stuff if keyboard only\n * ```\n *\n * @param mode - The {@link UserInteractionMode} to check against.\n * @returns `true` if the current user interaction mode matches the provided\n * mode.\n */\nexport function useIsUserInteractionMode(mode) {\n    return useUserInteractionMode() === mode;\n}\n/**\n * This component is used to determine how the user is current interacting with\n * your app as well as modifying the `document.body`'s `className` with the\n * current mode. This is what allows the `rmd-utils-phone-only`,\n * `rmd-utils-keyboard-only`, and `rmd-utils-mouse-only` mixins to work.\n *\n * @remarks \\@since 2.6.0 Renamed from `InteractionModeListener`\n * @throws When this component has been mounted multiple times in your app.\n */\nexport function UserInteractionModeListener(_a) {\n    var children = _a.children;\n    var mode = useInteractionMode();\n    if (useContext(parentContext)) {\n        throw new Error(\"Mounted multiple `UserInteractionModeListener` components.\");\n    }\n    return (_jsx(UserInteractionModeProvider, __assign({ value: mode }, { children: _jsx(ParentProvider, __assign({ value: true }, { children: children })) })));\n}\n//# sourceMappingURL=UserInteractionModeListener.js.map"]},"metadata":{},"sourceType":"module"}