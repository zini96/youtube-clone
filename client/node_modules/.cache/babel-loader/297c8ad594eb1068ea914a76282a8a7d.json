{"ast":null,"code":"import { loop } from \"../loop\";\n/**\n * @remarks \\@since 5.0.0\n * @internal\n */\n\nexport var focusElement = function (element) {\n  element.focus();\n};\n/**\n * @remarks \\@since 5.0.0\n * @internal\n */\n\nexport var isNotFocusable = function (element, includeDisabled) {\n  if (!element) {\n    return true;\n  }\n\n  if (includeDisabled) {\n    return false;\n  }\n\n  return element.getAttribute(\"disabled\") !== null || element.getAttribute(\"aria-disabled\") === \"true\";\n};\n/**\n * @remarks \\@since 5.0.0\n * @internal\n */\n\nexport var getFirstFocusableIndex = function (watching, includeDisabled) {\n  if (!watching.length) {\n    return -1;\n  }\n\n  var firstIndex = 0;\n\n  while (firstIndex < watching.length - 1 && isNotFocusable(watching[firstIndex].element, includeDisabled)) {\n    firstIndex += 1;\n  }\n\n  if (isNotFocusable(watching[firstIndex].element, includeDisabled)) {\n    return -1;\n  }\n\n  return firstIndex;\n};\n/**\n * @remarks \\@since 5.0.0\n * @internal\n */\n\nexport var getLastFocusableIndex = function (watching, includeDisabled) {\n  if (!watching.length) {\n    return -1;\n  }\n\n  var lastIndex = watching.length - 1;\n\n  while (lastIndex > 0 && isNotFocusable(watching[lastIndex].element, includeDisabled)) {\n    lastIndex -= 1;\n  }\n\n  if (isNotFocusable(watching[lastIndex].element, includeDisabled)) {\n    return -1;\n  }\n\n  return lastIndex;\n};\n/**\n * @remarks \\@since 5.0.0\n * @internal\n */\n\nexport var getNextFocusableIndex = function (_a) {\n  var loopable = _a.loopable,\n      watching = _a.watching,\n      increment = _a.increment,\n      includeDisabled = _a.includeDisabled,\n      currentFocusIndex = _a.currentFocusIndex;\n  var min = getFirstFocusableIndex(watching, includeDisabled);\n  var max = getLastFocusableIndex(watching, includeDisabled);\n  var nextIndex = loop({\n    min: min,\n    max: max,\n    value: currentFocusIndex,\n    minmax: !loopable,\n    increment: increment\n  });\n\n  while (isNotFocusable(watching[nextIndex].element, includeDisabled) && (loopable || nextIndex !== (increment ? max : min))) {\n    nextIndex = loop({\n      min: min,\n      max: max,\n      value: nextIndex,\n      minmax: !loopable,\n      increment: increment\n    });\n  } // Since the `min` and `max` values are \"safely\" set, I don't need to verify\n  // the nextIndex is still focusable\n\n\n  return nextIndex;\n};\n/**\n * @remarks \\@since 5.0.0\n * @internal\n */\n\nexport function getSearchText(element, searchable) {\n  if (!searchable) {\n    return \"\";\n  }\n\n  var cloned = element.cloneNode(true);\n  cloned.querySelectorAll(\".rmd-icon--font,[aria-hidden=true],[hidden]\").forEach(function (element) {\n    var _a;\n\n    (_a = element.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(element);\n  }); // Note: It would be good to use `cloned.innerText` (maybe?) at some point,\n  // but it returns `undefined` in jsdom. It also does cause a reflow, so maybe\n  // this is fine?\n  // https://developer.mozilla.org/en-US/docs/Web/API/Node/textContent#differences_from_innertext\n\n  return (cloned.textContent || \"\").substring(0, 1).toUpperCase();\n}","map":{"version":3,"sources":["../../src/keyboardMovement/utils.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { loop } from \"../loop\";\n/**\n * @remarks \\@since 5.0.0\n * @internal\n */\nexport var focusElement = function (element) {\n    element.focus();\n};\n/**\n * @remarks \\@since 5.0.0\n * @internal\n */\nexport var isNotFocusable = function (element, includeDisabled) {\n    if (!element) {\n        return true;\n    }\n    if (includeDisabled) {\n        return false;\n    }\n    return (element.getAttribute(\"disabled\") !== null ||\n        element.getAttribute(\"aria-disabled\") === \"true\");\n};\n/**\n * @remarks \\@since 5.0.0\n * @internal\n */\nexport var getFirstFocusableIndex = function (watching, includeDisabled) {\n    if (!watching.length) {\n        return -1;\n    }\n    var firstIndex = 0;\n    while (firstIndex < watching.length - 1 &&\n        isNotFocusable(watching[firstIndex].element, includeDisabled)) {\n        firstIndex += 1;\n    }\n    if (isNotFocusable(watching[firstIndex].element, includeDisabled)) {\n        return -1;\n    }\n    return firstIndex;\n};\n/**\n * @remarks \\@since 5.0.0\n * @internal\n */\nexport var getLastFocusableIndex = function (watching, includeDisabled) {\n    if (!watching.length) {\n        return -1;\n    }\n    var lastIndex = watching.length - 1;\n    while (lastIndex > 0 &&\n        isNotFocusable(watching[lastIndex].element, includeDisabled)) {\n        lastIndex -= 1;\n    }\n    if (isNotFocusable(watching[lastIndex].element, includeDisabled)) {\n        return -1;\n    }\n    return lastIndex;\n};\n/**\n * @remarks \\@since 5.0.0\n * @internal\n */\nexport var getNextFocusableIndex = function (_a) {\n    var loopable = _a.loopable, watching = _a.watching, increment = _a.increment, includeDisabled = _a.includeDisabled, currentFocusIndex = _a.currentFocusIndex;\n    var min = getFirstFocusableIndex(watching, includeDisabled);\n    var max = getLastFocusableIndex(watching, includeDisabled);\n    var nextIndex = loop({\n        min: min,\n        max: max,\n        value: currentFocusIndex,\n        minmax: !loopable,\n        increment: increment,\n    });\n    while (isNotFocusable(watching[nextIndex].element, includeDisabled) &&\n        (loopable || nextIndex !== (increment ? max : min))) {\n        nextIndex = loop({\n            min: min,\n            max: max,\n            value: nextIndex,\n            minmax: !loopable,\n            increment: increment,\n        });\n    }\n    // Since the `min` and `max` values are \"safely\" set, I don't need to verify\n    // the nextIndex is still focusable\n    return nextIndex;\n};\n/**\n * @remarks \\@since 5.0.0\n * @internal\n */\nexport function getSearchText(element, searchable) {\n    if (!searchable) {\n        return \"\";\n    }\n    var cloned = element.cloneNode(true);\n    cloned\n        .querySelectorAll(\".rmd-icon--font,[aria-hidden=true],[hidden]\")\n        .forEach(function (element) {\n        var _a;\n        (_a = element.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(element);\n    });\n    // Note: It would be good to use `cloned.innerText` (maybe?) at some point,\n    // but it returns `undefined` in jsdom. It also does cause a reflow, so maybe\n    // this is fine?\n    // https://developer.mozilla.org/en-US/docs/Web/API/Node/textContent#differences_from_innertext\n    return (cloned.textContent || \"\").substring(0, 1).toUpperCase();\n}\n//# sourceMappingURL=utils.js.map"]},"metadata":{},"sourceType":"module"}