{"ast":null,"code":"var __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nimport { useCallback, useEffect, useRef, useState } from \"react\";\nimport { useUserInteractionMode } from \"../mode\";\nimport { useOnUnmount } from \"../useOnUnmount\";\nimport { DEFAULT_HOVER_MODE_EXIT_TIME } from \"./constants\";\nimport { useHoverModeContext } from \"./useHoverModeContext\";\n/**\n * This hook is used to add the hover mode functionality to any component.\n *\n * @example\n * Displaying a Color Preview when hovering a Hex Code\n * ```tsx\n * import type { ReactElement } from \"react\";\n * import { CSSTransition } from \"@react-md/transition\";\n * import { useHoverMode } from \"@react-md/utils\";\n *\n * interface Props {\n *   value: string;\n * }\n *\n * export default function Color({ value }: Props): ReactElement {\n *   const { visible, onMouseEnter, onMouseLeave } =\n *     useHoverMode({ exitVisibilityDelay: 0 });\n *\n *   return (\n *     <>\n *       <span\n *         onMouseEnter={onMouseEnter}\n *         onMouseLeave={onMouseLeave}\n *         style={{\n *           // pretend styles\n *         }}\n *       >\n *         {value}\n *       </span>\n *       <CSSTransition\n *         transitionIn={visible}\n *         classNames=\"opacity-change\"\n *         timeout={150}\n *         temporary\n *       >\n *         <span\n *           style={{\n *             backgroundColor: value,\n *             // other styles\n *           }}\n *         />\n *      </CSSTransition>\n *     </>\n *   );\n * }\n * ```\n *\n * @example\n * Sticky Usage with a Fixed Dialog\n * ```tsx\n * const {\n *   stuck,\n *   active,\n *   visible,\n *   setVisible,\n *   handlers,\n *   hoverHandlers,\n * } = useHoverMode();\n * const buttonRef = useRef<HTMLButtonElement>(null);\n *\n * return (\n *   <>\n *     <Button {...handlers} ref={buttonRef}>\n *       Click Me\n *     </Button>\n *     <FixedDialog\n *       {...hoverHandlers}\n *       aria-labelledby=\"dialog-title-id\"\n *       id=\"dialog-id\"\n *       visible={visible}\n *       onRequestClose={() => setVisible(false)}\n *       fixedTo={buttonRef}\n *       anchor={BELOW_CENTER_ANCHOR}\n *       options={{ preventOverlap: true }}\n *       // this allows the close on outside click\"\" behavior\" to work\n *       overlay={!stuck && active ? false : undefined}\n *       disableScrollLock={active}\n *     >\n *       <YourDialogContent />\n *    </FixedDialog>\n *   </>\n * );\n * ```\n *\n * @remarks \\@since 2.8.0\n * @remarks \\@since 5.0.0 This hook no longer returns `handlers` or\n * `stickyHandlers` and does not hide when an element on the page is clicked.\n * @param options - An optional object of options to use. See\n * {@link HoverModeOptions} for more details.\n * @returns either the {@link HoverModeReturnValue} or {@link HoverModeReturnValue}\n */\n\nexport function useHoverMode(_a) {\n  var _b = _a === void 0 ? {} : _a,\n      _c = _b.disabled,\n      disabled = _c === void 0 ? false : _c,\n      _d = _b.defaultVisible,\n      defaultVisible = _d === void 0 ? false : _d,\n      _e = _b.exitVisibilityDelay,\n      exitVisibilityDelay = _e === void 0 ? DEFAULT_HOVER_MODE_EXIT_TIME : _e;\n\n  var mode = useUserInteractionMode();\n  var isTouch = mode === \"touch\";\n\n  var _f = __read(useState(defaultVisible), 2),\n      visible = _f[0],\n      setVisible = _f[1];\n\n  var _g = __read(useState(false), 2),\n      stuck = _g[0],\n      setStuck = _g[1];\n\n  var timeoutRef = useRef();\n\n  var _h = useHoverModeContext(),\n      visibleInTime = _h.visibleInTime,\n      enableHoverMode = _h.enableHoverMode,\n      disableHoverMode = _h.disableHoverMode,\n      startDisableTimer = _h.startDisableTimer;\n\n  var active = visibleInTime === 0;\n  useEffect(function () {\n    if (!visible) {\n      setStuck(false);\n    }\n  }, [visible]);\n  useOnUnmount(function () {\n    window.clearTimeout(timeoutRef.current);\n  });\n  var clearHoverTimeout = useCallback(function () {\n    window.clearTimeout(timeoutRef.current);\n  }, []);\n  var onMouseEnter = useCallback(function (event) {\n    if (stuck || disabled || isTouch || event.isPropagationStopped()) {\n      return;\n    }\n\n    clearHoverTimeout();\n\n    if (visibleInTime === 0) {\n      enableHoverMode();\n      setVisible(true);\n      return;\n    }\n\n    timeoutRef.current = window.setTimeout(function () {\n      enableHoverMode();\n      setVisible(true);\n    }, visibleInTime);\n  }, [clearHoverTimeout, disabled, enableHoverMode, isTouch, stuck, visibleInTime]);\n  var onMouseLeave = useCallback(function (event) {\n    if (stuck || disabled || isTouch || event.isPropagationStopped()) {\n      return;\n    }\n\n    startDisableTimer();\n    clearHoverTimeout();\n\n    if (exitVisibilityDelay === 0) {\n      setVisible(false);\n      return;\n    }\n\n    timeoutRef.current = window.setTimeout(function () {\n      setVisible(false);\n    }, exitVisibilityDelay);\n  }, [clearHoverTimeout, disabled, exitVisibilityDelay, isTouch, startDisableTimer, stuck]);\n  var onClick = useCallback(function (event) {\n    if (event.isPropagationStopped()) {\n      return;\n    } // If the hover mode functionality is disabled, just allow this to behave\n    // like a toggle visibility handler.\n\n\n    if (!stuck && !disabled) {\n      setStuck(true);\n      setVisible(true);\n    } else {\n      setStuck(false);\n      setVisible(function (prevVisible) {\n        return !prevVisible;\n      });\n    }\n  }, [disabled, stuck]);\n  return {\n    active: active,\n    stuck: stuck,\n    visible: visible,\n    setVisible: setVisible,\n    onClick: onClick,\n    onMouseEnter: onMouseEnter,\n    onMouseLeave: onMouseLeave,\n    enableHoverMode: enableHoverMode,\n    disableHoverMode: disableHoverMode,\n    startDisableTimer: startDisableTimer,\n    clearHoverTimeout: clearHoverTimeout,\n    handlers: {\n      onClick: onClick,\n      onMouseEnter: onMouseEnter,\n      onMouseLeave: onMouseLeave\n    },\n    hoverHandlers: {\n      onMouseEnter: onMouseEnter,\n      onMouseLeave: onMouseLeave\n    }\n  };\n}","map":{"version":3,"sources":["../../src/hover/useHoverMode.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nimport { useCallback, useEffect, useRef, useState } from \"react\";\nimport { useUserInteractionMode } from \"../mode\";\nimport { useOnUnmount } from \"../useOnUnmount\";\nimport { DEFAULT_HOVER_MODE_EXIT_TIME } from \"./constants\";\nimport { useHoverModeContext } from \"./useHoverModeContext\";\n/**\n * This hook is used to add the hover mode functionality to any component.\n *\n * @example\n * Displaying a Color Preview when hovering a Hex Code\n * ```tsx\n * import type { ReactElement } from \"react\";\n * import { CSSTransition } from \"@react-md/transition\";\n * import { useHoverMode } from \"@react-md/utils\";\n *\n * interface Props {\n *   value: string;\n * }\n *\n * export default function Color({ value }: Props): ReactElement {\n *   const { visible, onMouseEnter, onMouseLeave } =\n *     useHoverMode({ exitVisibilityDelay: 0 });\n *\n *   return (\n *     <>\n *       <span\n *         onMouseEnter={onMouseEnter}\n *         onMouseLeave={onMouseLeave}\n *         style={{\n *           // pretend styles\n *         }}\n *       >\n *         {value}\n *       </span>\n *       <CSSTransition\n *         transitionIn={visible}\n *         classNames=\"opacity-change\"\n *         timeout={150}\n *         temporary\n *       >\n *         <span\n *           style={{\n *             backgroundColor: value,\n *             // other styles\n *           }}\n *         />\n *      </CSSTransition>\n *     </>\n *   );\n * }\n * ```\n *\n * @example\n * Sticky Usage with a Fixed Dialog\n * ```tsx\n * const {\n *   stuck,\n *   active,\n *   visible,\n *   setVisible,\n *   handlers,\n *   hoverHandlers,\n * } = useHoverMode();\n * const buttonRef = useRef<HTMLButtonElement>(null);\n *\n * return (\n *   <>\n *     <Button {...handlers} ref={buttonRef}>\n *       Click Me\n *     </Button>\n *     <FixedDialog\n *       {...hoverHandlers}\n *       aria-labelledby=\"dialog-title-id\"\n *       id=\"dialog-id\"\n *       visible={visible}\n *       onRequestClose={() => setVisible(false)}\n *       fixedTo={buttonRef}\n *       anchor={BELOW_CENTER_ANCHOR}\n *       options={{ preventOverlap: true }}\n *       // this allows the close on outside click\"\" behavior\" to work\n *       overlay={!stuck && active ? false : undefined}\n *       disableScrollLock={active}\n *     >\n *       <YourDialogContent />\n *    </FixedDialog>\n *   </>\n * );\n * ```\n *\n * @remarks \\@since 2.8.0\n * @remarks \\@since 5.0.0 This hook no longer returns `handlers` or\n * `stickyHandlers` and does not hide when an element on the page is clicked.\n * @param options - An optional object of options to use. See\n * {@link HoverModeOptions} for more details.\n * @returns either the {@link HoverModeReturnValue} or {@link HoverModeReturnValue}\n */\nexport function useHoverMode(_a) {\n    var _b = _a === void 0 ? {} : _a, _c = _b.disabled, disabled = _c === void 0 ? false : _c, _d = _b.defaultVisible, defaultVisible = _d === void 0 ? false : _d, _e = _b.exitVisibilityDelay, exitVisibilityDelay = _e === void 0 ? DEFAULT_HOVER_MODE_EXIT_TIME : _e;\n    var mode = useUserInteractionMode();\n    var isTouch = mode === \"touch\";\n    var _f = __read(useState(defaultVisible), 2), visible = _f[0], setVisible = _f[1];\n    var _g = __read(useState(false), 2), stuck = _g[0], setStuck = _g[1];\n    var timeoutRef = useRef();\n    var _h = useHoverModeContext(), visibleInTime = _h.visibleInTime, enableHoverMode = _h.enableHoverMode, disableHoverMode = _h.disableHoverMode, startDisableTimer = _h.startDisableTimer;\n    var active = visibleInTime === 0;\n    useEffect(function () {\n        if (!visible) {\n            setStuck(false);\n        }\n    }, [visible]);\n    useOnUnmount(function () {\n        window.clearTimeout(timeoutRef.current);\n    });\n    var clearHoverTimeout = useCallback(function () {\n        window.clearTimeout(timeoutRef.current);\n    }, []);\n    var onMouseEnter = useCallback(function (event) {\n        if (stuck || disabled || isTouch || event.isPropagationStopped()) {\n            return;\n        }\n        clearHoverTimeout();\n        if (visibleInTime === 0) {\n            enableHoverMode();\n            setVisible(true);\n            return;\n        }\n        timeoutRef.current = window.setTimeout(function () {\n            enableHoverMode();\n            setVisible(true);\n        }, visibleInTime);\n    }, [\n        clearHoverTimeout,\n        disabled,\n        enableHoverMode,\n        isTouch,\n        stuck,\n        visibleInTime,\n    ]);\n    var onMouseLeave = useCallback(function (event) {\n        if (stuck || disabled || isTouch || event.isPropagationStopped()) {\n            return;\n        }\n        startDisableTimer();\n        clearHoverTimeout();\n        if (exitVisibilityDelay === 0) {\n            setVisible(false);\n            return;\n        }\n        timeoutRef.current = window.setTimeout(function () {\n            setVisible(false);\n        }, exitVisibilityDelay);\n    }, [\n        clearHoverTimeout,\n        disabled,\n        exitVisibilityDelay,\n        isTouch,\n        startDisableTimer,\n        stuck,\n    ]);\n    var onClick = useCallback(function (event) {\n        if (event.isPropagationStopped()) {\n            return;\n        }\n        // If the hover mode functionality is disabled, just allow this to behave\n        // like a toggle visibility handler.\n        if (!stuck && !disabled) {\n            setStuck(true);\n            setVisible(true);\n        }\n        else {\n            setStuck(false);\n            setVisible(function (prevVisible) { return !prevVisible; });\n        }\n    }, [disabled, stuck]);\n    return {\n        active: active,\n        stuck: stuck,\n        visible: visible,\n        setVisible: setVisible,\n        onClick: onClick,\n        onMouseEnter: onMouseEnter,\n        onMouseLeave: onMouseLeave,\n        enableHoverMode: enableHoverMode,\n        disableHoverMode: disableHoverMode,\n        startDisableTimer: startDisableTimer,\n        clearHoverTimeout: clearHoverTimeout,\n        handlers: {\n            onClick: onClick,\n            onMouseEnter: onMouseEnter,\n            onMouseLeave: onMouseLeave,\n        },\n        hoverHandlers: {\n            onMouseEnter: onMouseEnter,\n            onMouseLeave: onMouseLeave,\n        },\n    };\n}\n//# sourceMappingURL=useHoverMode.js.map"]},"metadata":{},"sourceType":"module"}