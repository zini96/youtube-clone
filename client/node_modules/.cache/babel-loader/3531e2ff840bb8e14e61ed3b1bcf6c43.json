{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nimport { useCallback, useEffect, useMemo, useRef, useState } from \"react\";\nimport { useOnUnmount } from \"../useOnUnmount\";\nimport { DEFAULT_HOVER_MODE_DEACTIVATION_TIME, DEFAULT_HOVER_MODE_VISIBLE_IN_TIME } from \"./constants\";\nimport { HoverModeContextProvider } from \"./useHoverModeContext\";\n/**\n * This component should normally be mounted near the root of your app to enable\n * hover mode for child components. However, it can also be used at other levels\n * if hover mode functionality should not carry over between two different parts\n * of the screen.\n *\n * @example\n * Separating Hover Mode\n * ```tsx\n * export default function Example(): ReactElement {\n *   return (\n *     <>\n *       <HoverModeProvider>\n *         <HeaderActions />\n *       </HoverModeProvider>\n *       <HoverModeProvider>\n *         <MainContent />\n *       </HoverModeProvider>\n *     </>\n *   );\n * }\n * ```\n *\n * @remarks \\@since 2.8.0\n */\n\nexport function HoverModeProvider(_a) {\n  var children = _a.children,\n      _b = _a.disabled,\n      disabled = _b === void 0 ? false : _b,\n      _c = _a.defaultVisibleInTime,\n      defaultVisibleInTime = _c === void 0 ? DEFAULT_HOVER_MODE_VISIBLE_IN_TIME : _c,\n      _d = _a.deactivateTime,\n      deactivateTime = _d === void 0 ? DEFAULT_HOVER_MODE_DEACTIVATION_TIME : _d;\n\n  var _e = __read(useState(defaultVisibleInTime), 2),\n      visibleInTime = _e[0],\n      setVisibleInTime = _e[1];\n\n  var timeoutRef = useRef();\n  var enableHoverMode = useCallback(function () {\n    if (disabled) {\n      return;\n    }\n\n    window.clearTimeout(timeoutRef.current);\n    setVisibleInTime(0);\n  }, [disabled]);\n  var disableHoverMode = useCallback(function () {\n    window.clearTimeout(timeoutRef.current);\n    setVisibleInTime(defaultVisibleInTime);\n  }, [defaultVisibleInTime]);\n  var startDisableTimer = useCallback(function () {\n    window.clearTimeout(timeoutRef.current);\n    timeoutRef.current = window.setTimeout(function () {\n      setVisibleInTime(defaultVisibleInTime);\n    }, deactivateTime);\n  }, [defaultVisibleInTime, deactivateTime]);\n  useEffect(function () {\n    if (disabled) {\n      window.clearTimeout(timeoutRef.current);\n      setVisibleInTime(defaultVisibleInTime);\n    }\n  }, [disabled, defaultVisibleInTime]);\n  useOnUnmount(function () {\n    window.clearTimeout(timeoutRef.current);\n  });\n  var context = useMemo(function () {\n    return {\n      visibleInTime: visibleInTime,\n      enableHoverMode: enableHoverMode,\n      disableHoverMode: disableHoverMode,\n      startDisableTimer: startDisableTimer\n    };\n  }, [disableHoverMode, enableHoverMode, startDisableTimer, visibleInTime]);\n  return _jsx(HoverModeContextProvider, __assign({\n    value: context\n  }, {\n    children: children\n  }));\n}","map":{"version":3,"sources":["../../src/hover/HoverModeProvider.tsx"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA,SAAS,WAAT,EAAsB,SAAtB,EAAiC,OAAjC,EAA0C,MAA1C,EAAkD,QAAlD,QAAkE,OAAlE;AAEA,SAAS,YAAT,QAA6B,iBAA7B;AACA,SACE,oCADF,EAEE,kCAFF,QAGO,aAHP;AAKA,SAAS,wBAAT,QAAyC,uBAAzC;AAiCA;;;;;;;;;;;;;;;;;;;;;;;;;;AAyBA,OAAM,SAAU,iBAAV,CAA4B,EAA5B,EAKmB;MAJvB,QAAQ,GAAA,EAAA,CAAA,Q;MACR,EAAA,GAAA,EAAA,CAAA,Q;MAAA,QAAQ,GAAA,EAAA,KAAA,KAAA,CAAA,GAAG,KAAH,GAAQ,E;MAChB,EAAA,GAAA,EAAA,CAAA,oB;MAAA,oBAAoB,GAAA,EAAA,KAAA,KAAA,CAAA,GAAG,kCAAH,GAAqC,E;MACzD,EAAA,GAAA,EAAA,CAAA,c;MAAA,cAAc,GAAA,EAAA,KAAA,KAAA,CAAA,GAAG,oCAAH,GAAuC,E;;AAE/C,MAAA,EAAA,GAAA,MAAA,CAAoC,QAAQ,CAAC,oBAAD,CAA5C,EAAkE,CAAlE,CAAA;AAAA,MAAC,aAAa,GAAA,EAAA,CAAA,CAAA,CAAd;AAAA,MAAgB,gBAAgB,GAAA,EAAA,CAAA,CAAA,CAAhC;;AACN,MAAM,UAAU,GAAG,MAAM,EAAzB;AACA,MAAM,eAAe,GAAG,WAAW,CAAC,YAAA;AAClC,QAAI,QAAJ,EAAc;AACZ;AACD;;AAED,IAAA,MAAM,CAAC,YAAP,CAAoB,UAAU,CAAC,OAA/B;AACA,IAAA,gBAAgB,CAAC,CAAD,CAAhB;AACD,GAPkC,EAOhC,CAAC,QAAD,CAPgC,CAAnC;AAQA,MAAM,gBAAgB,GAAG,WAAW,CAAC,YAAA;AACnC,IAAA,MAAM,CAAC,YAAP,CAAoB,UAAU,CAAC,OAA/B;AACA,IAAA,gBAAgB,CAAC,oBAAD,CAAhB;AACD,GAHmC,EAGjC,CAAC,oBAAD,CAHiC,CAApC;AAKA,MAAM,iBAAiB,GAAG,WAAW,CAAC,YAAA;AACpC,IAAA,MAAM,CAAC,YAAP,CAAoB,UAAU,CAAC,OAA/B;AACA,IAAA,UAAU,CAAC,OAAX,GAAqB,MAAM,CAAC,UAAP,CAAkB,YAAA;AACrC,MAAA,gBAAgB,CAAC,oBAAD,CAAhB;AACD,KAFoB,EAElB,cAFkB,CAArB;AAGD,GALoC,EAKlC,CAAC,oBAAD,EAAuB,cAAvB,CALkC,CAArC;AAOA,EAAA,SAAS,CAAC,YAAA;AACR,QAAI,QAAJ,EAAc;AACZ,MAAA,MAAM,CAAC,YAAP,CAAoB,UAAU,CAAC,OAA/B;AACA,MAAA,gBAAgB,CAAC,oBAAD,CAAhB;AACD;AACF,GALQ,EAKN,CAAC,QAAD,EAAW,oBAAX,CALM,CAAT;AAOA,EAAA,YAAY,CAAC,YAAA;AACX,IAAA,MAAM,CAAC,YAAP,CAAoB,UAAU,CAAC,OAA/B;AACD,GAFW,CAAZ;AAIA,MAAM,OAAO,GAAG,OAAO,CACrB,YAAA;AAAM,WAAC;AACL,MAAA,aAAa,EAAA,aADR;AAEL,MAAA,eAAe,EAAA,eAFV;AAGL,MAAA,gBAAgB,EAAA,gBAHX;AAIL,MAAA,iBAAiB,EAAA;AAJZ,KAAD;AAKJ,GANmB,EAOrB,CAAC,gBAAD,EAAmB,eAAnB,EAAoC,iBAApC,EAAuD,aAAvD,CAPqB,CAAvB;AAUA,SACE,IAAA,CAAC,wBAAD,EAAyB,QAAA,CAAA;AAAC,IAAA,KAAK,EAAE;AAAR,GAAA,EAAe;AAAA,IAAA,QAAA,EACrC;AADqC,GAAf,CAAzB,CADF;AAKD","sourceRoot":"","sourcesContent":["var __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nimport { useCallback, useEffect, useMemo, useRef, useState } from \"react\";\nimport { useOnUnmount } from \"../useOnUnmount\";\nimport { DEFAULT_HOVER_MODE_DEACTIVATION_TIME, DEFAULT_HOVER_MODE_VISIBLE_IN_TIME, } from \"./constants\";\nimport { HoverModeContextProvider } from \"./useHoverModeContext\";\n/**\n * This component should normally be mounted near the root of your app to enable\n * hover mode for child components. However, it can also be used at other levels\n * if hover mode functionality should not carry over between two different parts\n * of the screen.\n *\n * @example\n * Separating Hover Mode\n * ```tsx\n * export default function Example(): ReactElement {\n *   return (\n *     <>\n *       <HoverModeProvider>\n *         <HeaderActions />\n *       </HoverModeProvider>\n *       <HoverModeProvider>\n *         <MainContent />\n *       </HoverModeProvider>\n *     </>\n *   );\n * }\n * ```\n *\n * @remarks \\@since 2.8.0\n */\nexport function HoverModeProvider(_a) {\n    var children = _a.children, _b = _a.disabled, disabled = _b === void 0 ? false : _b, _c = _a.defaultVisibleInTime, defaultVisibleInTime = _c === void 0 ? DEFAULT_HOVER_MODE_VISIBLE_IN_TIME : _c, _d = _a.deactivateTime, deactivateTime = _d === void 0 ? DEFAULT_HOVER_MODE_DEACTIVATION_TIME : _d;\n    var _e = __read(useState(defaultVisibleInTime), 2), visibleInTime = _e[0], setVisibleInTime = _e[1];\n    var timeoutRef = useRef();\n    var enableHoverMode = useCallback(function () {\n        if (disabled) {\n            return;\n        }\n        window.clearTimeout(timeoutRef.current);\n        setVisibleInTime(0);\n    }, [disabled]);\n    var disableHoverMode = useCallback(function () {\n        window.clearTimeout(timeoutRef.current);\n        setVisibleInTime(defaultVisibleInTime);\n    }, [defaultVisibleInTime]);\n    var startDisableTimer = useCallback(function () {\n        window.clearTimeout(timeoutRef.current);\n        timeoutRef.current = window.setTimeout(function () {\n            setVisibleInTime(defaultVisibleInTime);\n        }, deactivateTime);\n    }, [defaultVisibleInTime, deactivateTime]);\n    useEffect(function () {\n        if (disabled) {\n            window.clearTimeout(timeoutRef.current);\n            setVisibleInTime(defaultVisibleInTime);\n        }\n    }, [disabled, defaultVisibleInTime]);\n    useOnUnmount(function () {\n        window.clearTimeout(timeoutRef.current);\n    });\n    var context = useMemo(function () { return ({\n        visibleInTime: visibleInTime,\n        enableHoverMode: enableHoverMode,\n        disableHoverMode: disableHoverMode,\n        startDisableTimer: startDisableTimer,\n    }); }, [disableHoverMode, enableHoverMode, startDisableTimer, visibleInTime]);\n    return (_jsx(HoverModeContextProvider, __assign({ value: context }, { children: children })));\n}\n//# sourceMappingURL=HoverModeProvider.js.map"]},"metadata":{},"sourceType":"module"}