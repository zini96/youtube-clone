{"ast":null,"code":"var __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nvar __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\n/**\n * Creates a throttled version of a function so that it'll be called with\n * trailing and leading calls. Since I always get this confused with `debounce`,\n * here's a quick summary of the differences:\n *\n * - debounce will wait to call the function until it hasn't been called again\n *   for the wait duration without trailing or leading calls. If it has the\n *   trailing and leading calls, I can't figure out how it's different than\n *   throttle.\n * - throttle will be called each time it is available to be called.\n *\n * So debounce is great for things like auto-save features if you want to save\n * whenever the user stops typing for a few seconds while throttle is good for\n * things like sending an API request when the user is typing so that it isn't\n * sent every keystroke, but every few letters. You _could_ also do debounce\n * here, but it'll feel more \"responsive\" to the user when throttled.\n *\n * @param fn - The function that should be throttled\n * @param wait - The number of milliseconds to wait before calling the function\n * again\n * @returns a throttled version of the function that'll return the last computed\n * value if it was called again during the \"wait\" period.\n */\n\n\nexport function throttle(fn, wait) {\n  var lastCalledTime = 0;\n  var timeout;\n  var result;\n  var args;\n\n  function trailingCall() {\n    lastCalledTime = Date.now();\n    timeout = undefined;\n    result = fn.apply(void 0, __spreadArray([], __read(args), false));\n  }\n\n  return function throttled() {\n    var nextArgs = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      nextArgs[_i] = arguments[_i];\n    }\n\n    args = nextArgs;\n    var now = Date.now();\n    var remaining = wait - (now - lastCalledTime);\n\n    if (remaining <= 0 || remaining > wait) {\n      lastCalledTime = now;\n      result = fn.apply(void 0, __spreadArray([], __read(args), false));\n    } else if (!timeout) {\n      timeout = window.setTimeout(trailingCall, remaining);\n    }\n\n    return result;\n  };\n}","map":{"version":3,"sources":["../src/throttle.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAcA;;;;;;;;;;;;;;;;;;;;;;;;;AAuBA,OAAM,SAAU,QAAV,CACJ,EADI,EAEJ,IAFI,EAEQ;AAEZ,MAAI,cAAc,GAAG,CAArB;AACA,MAAI,OAAJ;AACA,MAAI,MAAJ;AACA,MAAI,IAAJ;;AAEA,WAAS,YAAT,GAAqB;AACnB,IAAA,cAAc,GAAG,IAAI,CAAC,GAAL,EAAjB;AACA,IAAA,OAAO,GAAG,SAAV;AACA,IAAA,MAAM,GAAG,EAAE,CAAA,KAAF,CAAE,KAAA,CAAF,EAAE,aAAA,CAAA,EAAA,EAAA,MAAA,CAAI,IAAJ,CAAA,EAAQ,KAAR,CAAF,CAAT;AACD;;AAED,SAAO,SAAS,SAAT,GAAkB;AAAC,QAAA,QAAA,GAAA,EAAA;;SAAA,IAAA,EAAA,GAAA,C,EAAA,EAAA,GAAA,SAAA,CAAA,M,EAAA,EAAA,E,EAA0B;AAA1B,MAAA,QAAA,CAAA,EAAA,CAAA,GAAA,SAAA,CAAA,EAAA,CAAA;;;AACxB,IAAA,IAAI,GAAG,QAAP;AAEA,QAAM,GAAG,GAAG,IAAI,CAAC,GAAL,EAAZ;AACA,QAAM,SAAS,GAAG,IAAI,IAAI,GAAG,GAAG,cAAV,CAAtB;;AACA,QAAI,SAAS,IAAI,CAAb,IAAkB,SAAS,GAAG,IAAlC,EAAwC;AACtC,MAAA,cAAc,GAAG,GAAjB;AACA,MAAA,MAAM,GAAG,EAAE,CAAA,KAAF,CAAE,KAAA,CAAF,EAAE,aAAA,CAAA,EAAA,EAAA,MAAA,CAAI,IAAJ,CAAA,EAAQ,KAAR,CAAF,CAAT;AACD,KAHD,MAGO,IAAI,CAAC,OAAL,EAAc;AACnB,MAAA,OAAO,GAAG,MAAM,CAAC,UAAP,CAAkB,YAAlB,EAAgC,SAAhC,CAAV;AACD;;AAED,WAAO,MAAP;AACD,GAbD;AAcD","sourceRoot":"","sourcesContent":["var __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\n/**\n * Creates a throttled version of a function so that it'll be called with\n * trailing and leading calls. Since I always get this confused with `debounce`,\n * here's a quick summary of the differences:\n *\n * - debounce will wait to call the function until it hasn't been called again\n *   for the wait duration without trailing or leading calls. If it has the\n *   trailing and leading calls, I can't figure out how it's different than\n *   throttle.\n * - throttle will be called each time it is available to be called.\n *\n * So debounce is great for things like auto-save features if you want to save\n * whenever the user stops typing for a few seconds while throttle is good for\n * things like sending an API request when the user is typing so that it isn't\n * sent every keystroke, but every few letters. You _could_ also do debounce\n * here, but it'll feel more \"responsive\" to the user when throttled.\n *\n * @param fn - The function that should be throttled\n * @param wait - The number of milliseconds to wait before calling the function\n * again\n * @returns a throttled version of the function that'll return the last computed\n * value if it was called again during the \"wait\" period.\n */\nexport function throttle(fn, wait) {\n    var lastCalledTime = 0;\n    var timeout;\n    var result;\n    var args;\n    function trailingCall() {\n        lastCalledTime = Date.now();\n        timeout = undefined;\n        result = fn.apply(void 0, __spreadArray([], __read(args), false));\n    }\n    return function throttled() {\n        var nextArgs = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            nextArgs[_i] = arguments[_i];\n        }\n        args = nextArgs;\n        var now = Date.now();\n        var remaining = wait - (now - lastCalledTime);\n        if (remaining <= 0 || remaining > wait) {\n            lastCalledTime = now;\n            result = fn.apply(void 0, __spreadArray([], __read(args), false));\n        }\n        else if (!timeout) {\n            timeout = window.setTimeout(trailingCall, remaining);\n        }\n        return result;\n    };\n}\n//# sourceMappingURL=throttle.js.map"]},"metadata":{},"sourceType":"module"}