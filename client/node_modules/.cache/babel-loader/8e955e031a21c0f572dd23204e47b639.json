{"ast":null,"code":"var __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nimport { useCallback, useEffect, useRef } from \"react\";\nimport { useRefCache } from \"./useRefCache\";\nimport { useToggle } from \"./useToggle\";\n/**\n * Simple hook to use an timeout with auto setup and teardown. The provided\n * functions will be guaranteed to not change and are memoized.\n *\n * @param cb - The callback function to call\n * @param delay - The time in milliseconds the timer should delay between\n * executions of the callback function\n * @param defaultStarted - Boolean if the timeout should be started immediately.\n * @returns a list containing a function to start the timeout, a function to\n * stop the timeout, and a function to restart the timeout.\n */\n\nexport function useTimeout(cb, delay, defaultStarted) {\n  if (defaultStarted === void 0) {\n    defaultStarted = false;\n  }\n\n  var cbRef = useRefCache(cb);\n  var delayRef = useRefCache(delay);\n  var timeoutRef = useRef();\n\n  var _a = __read(useToggle(defaultStarted), 3),\n      enabled = _a[0],\n      start = _a[1],\n      disable = _a[2];\n\n  var clearTimeout = useCallback(function () {\n    window.clearTimeout(timeoutRef.current);\n    timeoutRef.current = undefined;\n  }, []);\n  /* eslint-disable react-hooks/exhaustive-deps */\n  // these are all guaranteed to not change since using refs or non-updating\n  // callbacks\n\n  var restart = useCallback(function () {\n    clearTimeout();\n    timeoutRef.current = window.setTimeout(function () {\n      cbRef.current();\n      disable();\n    }, delayRef.current);\n  }, []);\n  var stop = useCallback(function () {\n    clearTimeout();\n    disable();\n  }, []);\n  useEffect(function () {\n    if (!enabled) {\n      return;\n    }\n\n    timeoutRef.current = window.setTimeout(function () {\n      cbRef.current();\n      disable();\n    }, delay);\n    return function () {\n      clearTimeout();\n    };\n  }, [enabled, delay, disable]);\n  return [start, stop, restart];\n}","map":{"version":3,"sources":["../src/useTimeout.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;AAAA,SAAS,WAAT,EAAsB,SAAtB,EAAiC,MAAjC,QAA+C,OAA/C;AAEA,SAAS,WAAT,QAA4B,eAA5B;AACA,SAAS,SAAT,QAA0B,aAA1B;AAOA;;;;;;;;;;;;AAWA,OAAM,SAAU,UAAV,CACJ,EADI,EAEJ,KAFI,EAGJ,cAHI,EAG6C;AAAjD,MAAA,cAAA,KAAA,KAAA,CAAA,EAAA;AAAA,IAAA,cAAA,GAAA,KAAA;AAAiD;;AAEjD,MAAM,KAAK,GAAG,WAAW,CAAC,EAAD,CAAzB;AACA,MAAM,QAAQ,GAAG,WAAW,CAAC,KAAD,CAA5B;AACA,MAAM,UAAU,GAAG,MAAM,EAAzB;;AACM,MAAA,EAAA,GAAA,MAAA,CAA4B,SAAS,CAAC,cAAD,CAArC,EAAqD,CAArD,CAAA;AAAA,MAAC,OAAO,GAAA,EAAA,CAAA,CAAA,CAAR;AAAA,MAAU,KAAK,GAAA,EAAA,CAAA,CAAA,CAAf;AAAA,MAAiB,OAAO,GAAA,EAAA,CAAA,CAAA,CAAxB;;AAEN,MAAM,YAAY,GAAG,WAAW,CAAC,YAAA;AAC/B,IAAA,MAAM,CAAC,YAAP,CAAoB,UAAU,CAAC,OAA/B;AACA,IAAA,UAAU,CAAC,OAAX,GAAqB,SAArB;AACD,GAH+B,EAG7B,EAH6B,CAAhC;AAKA;AACA;AACA;;AACA,MAAM,OAAO,GAAG,WAAW,CAAC,YAAA;AAC1B,IAAA,YAAY;AACZ,IAAA,UAAU,CAAC,OAAX,GAAqB,MAAM,CAAC,UAAP,CAAkB,YAAA;AACrC,MAAA,KAAK,CAAC,OAAN;AACA,MAAA,OAAO;AACR,KAHoB,EAGlB,QAAQ,CAAC,OAHS,CAArB;AAID,GAN0B,EAMxB,EANwB,CAA3B;AAQA,MAAM,IAAI,GAAG,WAAW,CAAC,YAAA;AACvB,IAAA,YAAY;AACZ,IAAA,OAAO;AACR,GAHuB,EAGrB,EAHqB,CAAxB;AAKA,EAAA,SAAS,CAAC,YAAA;AACR,QAAI,CAAC,OAAL,EAAc;AACZ;AACD;;AAED,IAAA,UAAU,CAAC,OAAX,GAAqB,MAAM,CAAC,UAAP,CAAkB,YAAA;AACrC,MAAA,KAAK,CAAC,OAAN;AACA,MAAA,OAAO;AACR,KAHoB,EAGlB,KAHkB,CAArB;AAIA,WAAO,YAAA;AACL,MAAA,YAAY;AACb,KAFD;AAGD,GAZQ,EAYN,CAAC,OAAD,EAAU,KAAV,EAAiB,OAAjB,CAZM,CAAT;AAcA,SAAO,CAAC,KAAD,EAAQ,IAAR,EAAc,OAAd,CAAP;AACD","sourceRoot":"","sourcesContent":["var __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nimport { useCallback, useEffect, useRef } from \"react\";\nimport { useRefCache } from \"./useRefCache\";\nimport { useToggle } from \"./useToggle\";\n/**\n * Simple hook to use an timeout with auto setup and teardown. The provided\n * functions will be guaranteed to not change and are memoized.\n *\n * @param cb - The callback function to call\n * @param delay - The time in milliseconds the timer should delay between\n * executions of the callback function\n * @param defaultStarted - Boolean if the timeout should be started immediately.\n * @returns a list containing a function to start the timeout, a function to\n * stop the timeout, and a function to restart the timeout.\n */\nexport function useTimeout(cb, delay, defaultStarted) {\n    if (defaultStarted === void 0) { defaultStarted = false; }\n    var cbRef = useRefCache(cb);\n    var delayRef = useRefCache(delay);\n    var timeoutRef = useRef();\n    var _a = __read(useToggle(defaultStarted), 3), enabled = _a[0], start = _a[1], disable = _a[2];\n    var clearTimeout = useCallback(function () {\n        window.clearTimeout(timeoutRef.current);\n        timeoutRef.current = undefined;\n    }, []);\n    /* eslint-disable react-hooks/exhaustive-deps */\n    // these are all guaranteed to not change since using refs or non-updating\n    // callbacks\n    var restart = useCallback(function () {\n        clearTimeout();\n        timeoutRef.current = window.setTimeout(function () {\n            cbRef.current();\n            disable();\n        }, delayRef.current);\n    }, []);\n    var stop = useCallback(function () {\n        clearTimeout();\n        disable();\n    }, []);\n    useEffect(function () {\n        if (!enabled) {\n            return;\n        }\n        timeoutRef.current = window.setTimeout(function () {\n            cbRef.current();\n            disable();\n        }, delay);\n        return function () {\n            clearTimeout();\n        };\n    }, [enabled, delay, disable]);\n    return [start, stop, restart];\n}\n//# sourceMappingURL=useTimeout.js.map"]},"metadata":{},"sourceType":"module"}