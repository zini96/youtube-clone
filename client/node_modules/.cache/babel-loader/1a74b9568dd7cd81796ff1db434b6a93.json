{"ast":null,"code":"import { BELOW_CENTER_ANCHOR } from \"./constants\";\nimport { createHorizontalPosition } from \"./createHorizontalPosition\";\nimport { createVerticalPosition } from \"./createVerticalPosition\";\nimport { findSizingContainer } from \"./findSizingContainer\";\nimport { getElementRect } from \"./getElementRect\";\nimport { getTransformOrigin } from \"./getTransformOrigin\";\nimport { getViewportSize } from \"./getViewportSize\";\n/**\n * This is used when there is no `container` element so that some styles can\n * still be created. The main use-case for this is context menus and when the\n * `initialX` and `initialY` options have been provided.\n *\n * @internal\n * @remarks \\@since 5.0.0\n */\n\nvar FALLBACK_DOM_RECT = {\n  x: 0,\n  y: 0,\n  height: 0,\n  width: 0,\n  left: 0,\n  right: 0,\n  top: 0,\n  bottom: 0,\n  toJSON: function () {// do nothing\n  }\n};\n/**\n * One of the most complicated functions in this project that will attempt to\n * position an element relative to another container element while still being\n * visible within the viewport. Below is the logical flow for attempting to fix\n * the element to the container:\n *\n * No Container: If there is no container element, return the provided x and y\n * positions and no styles since there's nothing we can use to calculate the\n * position.\n *\n * No Element: If the container was provided but the element to position does\n * not exist, return an style object containing the `left` and `top` values for\n * the container and apply as many of the positioning options as possible so\n * that the styles are \"as close as possible\" before the fixed element is added\n * to the DOM. This will also return the provided x and y positions since\n * nothing could be swapped around yet.\n *\n * Container and Element: If both the container and fixed element were provided,\n * apply all the positioning options to the `left` and `top` values of the\n * container based on the sizes of both elements.\n *\n * Now that the `left` and `top` values were applied, check to see if the\n * element is fully visible within the viewport with the provided positioning\n * options. If it is fully visible, do nothing else. If it isn't... follow the\n * next flow:\n *\n * First, check the horizontal sizes and make sure that the element is still\n * within the viewport with the provided viewwidth margin. If it isn't, first\n * try to swap only to a `right` style instead of left to see if that fixes it,\n * otherwise keep both the `left` and `right` styles.\n */\n\nexport function getFixedPosition(_a) {\n  var _b;\n\n  var container = _a.container,\n      element = _a.element,\n      _c = _a.anchor,\n      anchor = _c === void 0 ? BELOW_CENTER_ANCHOR : _c,\n      initialX = _a.initialX,\n      initialY = _a.initialY,\n      _d = _a.vwMargin,\n      vwMargin = _d === void 0 ? 16 : _d,\n      _e = _a.vhMargin,\n      vhMargin = _e === void 0 ? 16 : _e,\n      _f = _a.xMargin,\n      xMargin = _f === void 0 ? 0 : _f,\n      _g = _a.yMargin,\n      yMargin = _g === void 0 ? 0 : _g,\n      _h = _a.width,\n      widthType = _h === void 0 ? \"auto\" : _h,\n      _j = _a.preventOverlap,\n      preventOverlap = _j === void 0 ? false : _j,\n      _k = _a.transformOrigin,\n      transformOrigin = _k === void 0 ? false : _k,\n      _l = _a.disableSwapping,\n      propDisableSwapping = _l === void 0 ? false : _l,\n      _m = _a.disableVHBounds,\n      disableVHBounds = _m === void 0 ? false : _m;\n  container = findSizingContainer(container);\n\n  if (process.env.NODE_ENV !== \"production\") {\n    if (widthType !== \"auto\" && anchor.x !== \"center\") {\n      throw new Error('Unable to use a calculated width when the horizontal anchor is not `\"center\"`.');\n    }\n\n    if (preventOverlap && anchor.y !== \"above\" && anchor.y !== \"below\") {\n      throw new Error('Unable to prevent overlap when the vertical anchor is not `\"above\"` or `\"below\"`');\n    }\n  }\n\n  if (!element) {\n    return {\n      actualX: anchor.x,\n      actualY: anchor.y\n    };\n  }\n\n  var containerRect = (_b = container === null || container === void 0 ? void 0 : container.getBoundingClientRect()) !== null && _b !== void 0 ? _b : FALLBACK_DOM_RECT;\n  var vh = getViewportSize(\"height\");\n  var vw = getViewportSize(\"width\");\n\n  var _o = getElementRect(element),\n      height = _o.height,\n      elWidth = _o.width;\n\n  if (disableVHBounds) {\n    var dialog = element.closest(\"[role='dialog']\");\n\n    if (!dialog) {\n      initialY = (initialY !== null && initialY !== void 0 ? initialY : 0) + window.scrollY;\n    }\n  }\n\n  var disableSwapping = propDisableSwapping || !container;\n\n  var _p = createHorizontalPosition({\n    x: anchor.x,\n    vw: vw,\n    vwMargin: vwMargin,\n    xMargin: xMargin,\n    width: widthType,\n    elWidth: elWidth,\n    initialX: initialX,\n    containerRect: containerRect,\n    disableSwapping: disableSwapping\n  }),\n      left = _p.left,\n      right = _p.right,\n      width = _p.width,\n      minWidth = _p.minWidth,\n      actualX = _p.actualX;\n\n  var _q = createVerticalPosition({\n    y: anchor.y,\n    vh: vh,\n    vhMargin: vhMargin,\n    yMargin: yMargin,\n    initialY: initialY,\n    elHeight: height,\n    containerRect: containerRect,\n    disableSwapping: disableSwapping,\n    preventOverlap: preventOverlap,\n    disableVHBounds: disableVHBounds\n  }),\n      top = _q.top,\n      bottom = _q.bottom,\n      actualY = _q.actualY;\n\n  return {\n    actualX: actualX,\n    actualY: actualY,\n    style: {\n      left: left,\n      top: top,\n      right: right,\n      bottom: bottom,\n      width: width,\n      minWidth: minWidth,\n      position: disableVHBounds ? \"absolute\" : \"fixed\",\n      transformOrigin: transformOrigin ? getTransformOrigin({\n        x: actualX,\n        y: actualY\n      }) : undefined\n    }\n  };\n}","map":{"version":3,"sources":["../../src/positioning/getFixedPosition.ts"],"names":[],"mappings":"AAAA,SAAS,mBAAT,QAAoC,aAApC;AACA,SAAS,wBAAT,QAAyC,4BAAzC;AACA,SAAS,sBAAT,QAAuC,0BAAvC;AACA,SAAS,mBAAT,QAAoC,uBAApC;AACA,SAAS,cAAT,QAA+B,kBAA/B;AACA,SAAS,kBAAT,QAAmC,sBAAnC;AACA,SAAS,eAAT,QAAgC,mBAAhC;AAGA;;;;;;;;;AAQA,IAAM,iBAAiB,GAAY;AACjC,EAAA,CAAC,EAAE,CAD8B;AAEjC,EAAA,CAAC,EAAE,CAF8B;AAGjC,EAAA,MAAM,EAAE,CAHyB;AAIjC,EAAA,KAAK,EAAE,CAJ0B;AAKjC,EAAA,IAAI,EAAE,CAL2B;AAMjC,EAAA,KAAK,EAAE,CAN0B;AAOjC,EAAA,GAAG,EAAE,CAP4B;AAQjC,EAAA,MAAM,EAAE,CARyB;AASjC,EAAA,MAAM,EAAA,YAAA,CACJ;AACD;AAXgC,CAAnC;AAcA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA+BA,OAAM,SAAU,gBAAV,CAA2B,EAA3B,EAeiB;;;MAdrB,SAAS,GAAA,EAAA,CAAA,S;MACT,OAAO,GAAA,EAAA,CAAA,O;MACP,EAAA,GAAA,EAAA,CAAA,M;MAAA,MAAM,GAAA,EAAA,KAAA,KAAA,CAAA,GAAG,mBAAH,GAAsB,E;MAC5B,QAAQ,GAAA,EAAA,CAAA,Q;MACR,QAAQ,GAAA,EAAA,CAAA,Q;MACR,EAAA,GAAA,EAAA,CAAA,Q;MAAA,QAAQ,GAAA,EAAA,KAAA,KAAA,CAAA,GAAG,EAAH,GAAK,E;MACb,EAAA,GAAA,EAAA,CAAA,Q;MAAA,QAAQ,GAAA,EAAA,KAAA,KAAA,CAAA,GAAG,EAAH,GAAK,E;MACb,EAAA,GAAA,EAAA,CAAA,O;MAAA,OAAO,GAAA,EAAA,KAAA,KAAA,CAAA,GAAG,CAAH,GAAI,E;MACX,EAAA,GAAA,EAAA,CAAA,O;MAAA,OAAO,GAAA,EAAA,KAAA,KAAA,CAAA,GAAG,CAAH,GAAI,E;MACX,EAAA,GAAA,EAAA,CAAA,K;MAAO,SAAS,GAAA,EAAA,KAAA,KAAA,CAAA,GAAG,MAAH,GAAS,E;MACzB,EAAA,GAAA,EAAA,CAAA,c;MAAA,cAAc,GAAA,EAAA,KAAA,KAAA,CAAA,GAAG,KAAH,GAAQ,E;MACtB,EAAA,GAAA,EAAA,CAAA,e;MAAA,eAAe,GAAA,EAAA,KAAA,KAAA,CAAA,GAAG,KAAH,GAAQ,E;MACvB,EAAA,GAAA,EAAA,CAAA,e;MAAiB,mBAAmB,GAAA,EAAA,KAAA,KAAA,CAAA,GAAG,KAAH,GAAQ,E;MAC5C,EAAA,GAAA,EAAA,CAAA,e;MAAA,eAAe,GAAA,EAAA,KAAA,KAAA,CAAA,GAAG,KAAH,GAAQ,E;AAEvB,EAAA,SAAS,GAAG,mBAAmB,CAAC,SAAD,CAA/B;;AAEA,MAAI,OAAO,CAAC,GAAR,CAAY,QAAZ,KAAyB,YAA7B,EAA2C;AACzC,QAAI,SAAS,KAAK,MAAd,IAAwB,MAAM,CAAC,CAAP,KAAa,QAAzC,EAAmD;AACjD,YAAM,IAAI,KAAJ,CACJ,gFADI,CAAN;AAGD;;AAED,QAAI,cAAc,IAAI,MAAM,CAAC,CAAP,KAAa,OAA/B,IAA0C,MAAM,CAAC,CAAP,KAAa,OAA3D,EAAoE;AAClE,YAAM,IAAI,KAAJ,CACJ,kFADI,CAAN;AAGD;AACF;;AAED,MAAI,CAAC,OAAL,EAAc;AACZ,WAAO;AACL,MAAA,OAAO,EAAE,MAAM,CAAC,CADX;AAEL,MAAA,OAAO,EAAE,MAAM,CAAC;AAFX,KAAP;AAID;;AAED,MAAM,aAAa,GAAG,CAAA,EAAA,GAAA,SAAS,KAAA,IAAT,IAAA,SAAS,KAAA,KAAA,CAAT,GAAS,KAAA,CAAT,GAAA,SAAS,CAAE,qBAAX,EAAA,MAAkC,IAAlC,IAAkC,EAAA,KAAA,KAAA,CAAlC,GAAkC,EAAlC,GAAsC,iBAA5D;AACA,MAAM,EAAE,GAAG,eAAe,CAAC,QAAD,CAA1B;AACA,MAAM,EAAE,GAAG,eAAe,CAAC,OAAD,CAA1B;;AAEM,MAAA,EAAA,GAA6B,cAAc,CAAC,OAAD,CAA3C;AAAA,MAAE,MAAM,GAAA,EAAA,CAAA,MAAR;AAAA,MAAiB,OAAO,GAAA,EAAA,CAAA,KAAxB;;AACN,MAAI,eAAJ,EAAqB;AACnB,QAAM,MAAM,GAAG,OAAO,CAAC,OAAR,CAAgB,iBAAhB,CAAf;;AACA,QAAI,CAAC,MAAL,EAAa;AACX,MAAA,QAAQ,GAAG,CAAC,QAAQ,KAAA,IAAR,IAAA,QAAQ,KAAA,KAAA,CAAR,GAAA,QAAA,GAAY,CAAb,IAAkB,MAAM,CAAC,OAApC;AACD;AACF;;AAED,MAAM,eAAe,GAAG,mBAAmB,IAAI,CAAC,SAAhD;;AAEM,MAAA,EAAA,GAA4C,wBAAwB,CAAC;AACzE,IAAA,CAAC,EAAE,MAAM,CAAC,CAD+D;AAEzE,IAAA,EAAE,EAAA,EAFuE;AAGzE,IAAA,QAAQ,EAAA,QAHiE;AAIzE,IAAA,OAAO,EAAA,OAJkE;AAKzE,IAAA,KAAK,EAAE,SALkE;AAMzE,IAAA,OAAO,EAAA,OANkE;AAOzE,IAAA,QAAQ,EAAA,QAPiE;AAQzE,IAAA,aAAa,EAAA,aAR4D;AASzE,IAAA,eAAe,EAAA;AAT0D,GAAD,CAApE;AAAA,MAAE,IAAI,GAAA,EAAA,CAAA,IAAN;AAAA,MAAQ,KAAK,GAAA,EAAA,CAAA,KAAb;AAAA,MAAe,KAAK,GAAA,EAAA,CAAA,KAApB;AAAA,MAAsB,QAAQ,GAAA,EAAA,CAAA,QAA9B;AAAA,MAAgC,OAAO,GAAA,EAAA,CAAA,OAAvC;;AAWA,MAAA,EAAA,GAA2B,sBAAsB,CAAC;AACtD,IAAA,CAAC,EAAE,MAAM,CAAC,CAD4C;AAEtD,IAAA,EAAE,EAAA,EAFoD;AAGtD,IAAA,QAAQ,EAAA,QAH8C;AAItD,IAAA,OAAO,EAAA,OAJ+C;AAKtD,IAAA,QAAQ,EAAA,QAL8C;AAMtD,IAAA,QAAQ,EAAE,MAN4C;AAOtD,IAAA,aAAa,EAAA,aAPyC;AAQtD,IAAA,eAAe,EAAA,eARuC;AAStD,IAAA,cAAc,EAAA,cATwC;AAUtD,IAAA,eAAe,EAAA;AAVuC,GAAD,CAAjD;AAAA,MAAE,GAAG,GAAA,EAAA,CAAA,GAAL;AAAA,MAAO,MAAM,GAAA,EAAA,CAAA,MAAb;AAAA,MAAe,OAAO,GAAA,EAAA,CAAA,OAAtB;;AAaN,SAAO;AACL,IAAA,OAAO,EAAA,OADF;AAEL,IAAA,OAAO,EAAA,OAFF;AAGL,IAAA,KAAK,EAAE;AACL,MAAA,IAAI,EAAA,IADC;AAEL,MAAA,GAAG,EAAA,GAFE;AAGL,MAAA,KAAK,EAAA,KAHA;AAIL,MAAA,MAAM,EAAA,MAJD;AAKL,MAAA,KAAK,EAAA,KALA;AAML,MAAA,QAAQ,EAAA,QANH;AAOL,MAAA,QAAQ,EAAE,eAAe,GAAG,UAAH,GAAgB,OAPpC;AAQL,MAAA,eAAe,EAAE,eAAe,GAC5B,kBAAkB,CAAC;AAAE,QAAA,CAAC,EAAE,OAAL;AAAc,QAAA,CAAC,EAAE;AAAjB,OAAD,CADU,GAE5B;AAVC;AAHF,GAAP;AAgBD","sourceRoot":"","sourcesContent":["import { BELOW_CENTER_ANCHOR } from \"./constants\";\nimport { createHorizontalPosition } from \"./createHorizontalPosition\";\nimport { createVerticalPosition } from \"./createVerticalPosition\";\nimport { findSizingContainer } from \"./findSizingContainer\";\nimport { getElementRect } from \"./getElementRect\";\nimport { getTransformOrigin } from \"./getTransformOrigin\";\nimport { getViewportSize } from \"./getViewportSize\";\n/**\n * This is used when there is no `container` element so that some styles can\n * still be created. The main use-case for this is context menus and when the\n * `initialX` and `initialY` options have been provided.\n *\n * @internal\n * @remarks \\@since 5.0.0\n */\nvar FALLBACK_DOM_RECT = {\n    x: 0,\n    y: 0,\n    height: 0,\n    width: 0,\n    left: 0,\n    right: 0,\n    top: 0,\n    bottom: 0,\n    toJSON: function () {\n        // do nothing\n    },\n};\n/**\n * One of the most complicated functions in this project that will attempt to\n * position an element relative to another container element while still being\n * visible within the viewport. Below is the logical flow for attempting to fix\n * the element to the container:\n *\n * No Container: If there is no container element, return the provided x and y\n * positions and no styles since there's nothing we can use to calculate the\n * position.\n *\n * No Element: If the container was provided but the element to position does\n * not exist, return an style object containing the `left` and `top` values for\n * the container and apply as many of the positioning options as possible so\n * that the styles are \"as close as possible\" before the fixed element is added\n * to the DOM. This will also return the provided x and y positions since\n * nothing could be swapped around yet.\n *\n * Container and Element: If both the container and fixed element were provided,\n * apply all the positioning options to the `left` and `top` values of the\n * container based on the sizes of both elements.\n *\n * Now that the `left` and `top` values were applied, check to see if the\n * element is fully visible within the viewport with the provided positioning\n * options. If it is fully visible, do nothing else. If it isn't... follow the\n * next flow:\n *\n * First, check the horizontal sizes and make sure that the element is still\n * within the viewport with the provided viewwidth margin. If it isn't, first\n * try to swap only to a `right` style instead of left to see if that fixes it,\n * otherwise keep both the `left` and `right` styles.\n */\nexport function getFixedPosition(_a) {\n    var _b;\n    var container = _a.container, element = _a.element, _c = _a.anchor, anchor = _c === void 0 ? BELOW_CENTER_ANCHOR : _c, initialX = _a.initialX, initialY = _a.initialY, _d = _a.vwMargin, vwMargin = _d === void 0 ? 16 : _d, _e = _a.vhMargin, vhMargin = _e === void 0 ? 16 : _e, _f = _a.xMargin, xMargin = _f === void 0 ? 0 : _f, _g = _a.yMargin, yMargin = _g === void 0 ? 0 : _g, _h = _a.width, widthType = _h === void 0 ? \"auto\" : _h, _j = _a.preventOverlap, preventOverlap = _j === void 0 ? false : _j, _k = _a.transformOrigin, transformOrigin = _k === void 0 ? false : _k, _l = _a.disableSwapping, propDisableSwapping = _l === void 0 ? false : _l, _m = _a.disableVHBounds, disableVHBounds = _m === void 0 ? false : _m;\n    container = findSizingContainer(container);\n    if (process.env.NODE_ENV !== \"production\") {\n        if (widthType !== \"auto\" && anchor.x !== \"center\") {\n            throw new Error('Unable to use a calculated width when the horizontal anchor is not `\"center\"`.');\n        }\n        if (preventOverlap && anchor.y !== \"above\" && anchor.y !== \"below\") {\n            throw new Error('Unable to prevent overlap when the vertical anchor is not `\"above\"` or `\"below\"`');\n        }\n    }\n    if (!element) {\n        return {\n            actualX: anchor.x,\n            actualY: anchor.y,\n        };\n    }\n    var containerRect = (_b = container === null || container === void 0 ? void 0 : container.getBoundingClientRect()) !== null && _b !== void 0 ? _b : FALLBACK_DOM_RECT;\n    var vh = getViewportSize(\"height\");\n    var vw = getViewportSize(\"width\");\n    var _o = getElementRect(element), height = _o.height, elWidth = _o.width;\n    if (disableVHBounds) {\n        var dialog = element.closest(\"[role='dialog']\");\n        if (!dialog) {\n            initialY = (initialY !== null && initialY !== void 0 ? initialY : 0) + window.scrollY;\n        }\n    }\n    var disableSwapping = propDisableSwapping || !container;\n    var _p = createHorizontalPosition({\n        x: anchor.x,\n        vw: vw,\n        vwMargin: vwMargin,\n        xMargin: xMargin,\n        width: widthType,\n        elWidth: elWidth,\n        initialX: initialX,\n        containerRect: containerRect,\n        disableSwapping: disableSwapping,\n    }), left = _p.left, right = _p.right, width = _p.width, minWidth = _p.minWidth, actualX = _p.actualX;\n    var _q = createVerticalPosition({\n        y: anchor.y,\n        vh: vh,\n        vhMargin: vhMargin,\n        yMargin: yMargin,\n        initialY: initialY,\n        elHeight: height,\n        containerRect: containerRect,\n        disableSwapping: disableSwapping,\n        preventOverlap: preventOverlap,\n        disableVHBounds: disableVHBounds,\n    }), top = _q.top, bottom = _q.bottom, actualY = _q.actualY;\n    return {\n        actualX: actualX,\n        actualY: actualY,\n        style: {\n            left: left,\n            top: top,\n            right: right,\n            bottom: bottom,\n            width: width,\n            minWidth: minWidth,\n            position: disableVHBounds ? \"absolute\" : \"fixed\",\n            transformOrigin: transformOrigin\n                ? getTransformOrigin({ x: actualX, y: actualY })\n                : undefined,\n        },\n    };\n}\n//# sourceMappingURL=getFixedPosition.js.map"]},"metadata":{},"sourceType":"module"}